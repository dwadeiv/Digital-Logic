$date
	Mon Oct 07 11:47:16 2019
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module tb $end
$var wire 8 ! HEX5 [7:0] $end
$var wire 8 " HEX4 [7:0] $end
$var wire 8 # HEX3 [7:0] $end
$var wire 8 $ HEX2 [7:0] $end
$var wire 8 % HEX1 [7:0] $end
$var wire 8 & HEX0 [7:0] $end
$var reg 2 ' KEY [1:0] $end
$var reg 8 ( SW [7:0] $end
$scope module DUT $end
$var wire 2 ) KEY [1:0] $end
$var wire 8 * SW [7:0] $end
$var wire 1 + overflow $end
$var wire 4 , input2 [3:0] $end
$var wire 4 - input1 [3:0] $end
$var wire 5 . h5neg [4:0] $end
$var wire 5 / h3neg [4:0] $end
$var wire 5 0 ansDigit2 [4:0] $end
$var wire 5 1 ansDigit1 [4:0] $end
$var wire 4 2 ans [3:0] $end
$var wire 8 3 HEX5 [7:0] $end
$var wire 8 4 HEX4 [7:0] $end
$var wire 8 5 HEX3 [7:0] $end
$var wire 8 6 HEX2 [7:0] $end
$var wire 8 7 HEX1 [7:0] $end
$var wire 8 8 HEX0 [7:0] $end
$var reg 4 9 absAns [3:0] $end
$var reg 5 : absInput1 [4:0] $end
$var reg 5 ; absInput2 [4:0] $end
$scope module h0 $end
$var wire 5 < num [4:0] $end
$var reg 8 = out [7:0] $end
$upscope $end
$scope module h1 $end
$var wire 5 > num [4:0] $end
$var reg 8 ? out [7:0] $end
$upscope $end
$scope module h2 $end
$var wire 5 @ num [4:0] $end
$var reg 8 A out [7:0] $end
$upscope $end
$scope module h3 $end
$var wire 5 B num [4:0] $end
$var reg 8 C out [7:0] $end
$upscope $end
$scope module h4 $end
$var wire 5 D num [4:0] $end
$var reg 8 E out [7:0] $end
$upscope $end
$scope module h5 $end
$var wire 5 F num [4:0] $end
$var reg 8 G out [7:0] $end
$upscope $end
$scope module r $end
$var wire 4 H a [3:0] $end
$var wire 4 I b [3:0] $end
$var wire 1 J sub $end
$var wire 4 K sum [3:0] $end
$var wire 1 L carry4 $end
$var wire 1 M carry3 $end
$var wire 1 N carry2 $end
$var wire 1 O carry1 $end
$var reg 1 + overflow $end
$scope module a0 $end
$var wire 1 P a $end
$var wire 1 Q b $end
$var wire 1 R c $end
$var wire 1 O carry $end
$var wire 1 S sum $end
$upscope $end
$scope module a1 $end
$var wire 1 T a $end
$var wire 1 U b $end
$var wire 1 O c $end
$var wire 1 N carry $end
$var wire 1 V sum $end
$upscope $end
$scope module a2 $end
$var wire 1 W a $end
$var wire 1 X b $end
$var wire 1 N c $end
$var wire 1 M carry $end
$var wire 1 Y sum $end
$upscope $end
$scope module a3 $end
$var wire 1 Z a $end
$var wire 1 [ b $end
$var wire 1 M c $end
$var wire 1 L carry $end
$var wire 1 \ sum $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0\
0[
0Z
0Y
0X
0W
1V
0U
0T
0S
0R
1Q
1P
1O
0N
0M
0L
b10 K
1J
b1 I
b1 H
b11111111 G
b10001 F
bx E
bx D
b11111111 C
b10001 B
bx A
bx @
b11111111 ?
b10001 >
b10100100 =
b10 <
bx ;
bx :
b10 9
b10100100 8
b11111111 7
bx 6
b11111111 5
bx 4
b11111111 3
b10 2
b10001 1
b10 0
b10001 /
b10001 .
b1 -
b1 ,
0+
b10001 *
b11 )
b10001 (
b11 '
b10100100 &
b11111111 %
bx $
b11111111 #
bx "
b11111111 !
$end
#100
